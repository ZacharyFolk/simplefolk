!function (n, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (n = "undefined" != typeof globalThis ? globalThis : n || self).EmblaCarousel = t() }(this, (function () { "use strict"; function n(n) { return "number" == typeof n } function t(n) { return "string" == typeof n } function e(n) { return "boolean" == typeof n } function r(n) { return "[object Object]" === Object.prototype.toString.call(n) } function o(n) { return Math.abs(n) } function i(n) { return Math.sign(n) } function c(n, t) { return o(n - t) } function u(n) { return d(n).map(Number) } function s(n) { return n[a(n)] } function a(n) { return Math.max(0, n.length - 1) } function l(n, t = 0) { return Array.from(Array(n), ((n, e) => t + e)) } function d(n) { return Object.keys(n) } function f(n, t) { return [n, t].reduce(((n, t) => (d(t).forEach((e => { const o = n[e], i = t[e], c = r(o) && r(i); n[e] = c ? f(o, i) : i })), n)), {}) } function p(n, t) { return void 0 !== t.MouseEvent && n instanceof t.MouseEvent } function m(t, e) { const r = { start: function () { return 0 }, center: function (n) { return o(n) / 2 }, end: o }; function o(n) { return e - n } return { measure: function (o) { return n(t) ? e * Number(t) : r[t](o) } } } function g(n, t) { const e = o(n - t); function r(t) { return t < n } function i(n) { return n > t } function c(n) { return r(n) || i(n) } return { length: e, max: t, min: n, constrain: function (e) { return c(e) ? r(e) ? n : t : e }, reachedAny: c, reachedMax: i, reachedMin: r, removeOffset: function (n) { return e ? n - e * Math.ceil((n - t) / e) : n } } } function h(n, t, e) { const { constrain: r } = g(0, n), i = n + 1; let c = u(t); function u(n) { return e ? o((i + n) % i) : r(n) } function s() { return c } function a() { return h(n, s(), e) } const l = { get: s, set: function (n) { return c = u(n), l }, add: function (n) { return a().set(s() + n) }, clone: a }; return l } function x() { let n = []; const t = { add: function (e, r, o, i = { passive: !0 }) { let c; if ("addEventListener" in e) e.addEventListener(r, o, i), c = () => e.removeEventListener(r, o, i); else { const n = e; n.addListener(o), c = () => n.removeListener(o) } return n.push(c), t }, clear: function () { n = n.filter((n => n())) } }; return t } function y(n, t, r, u, s, a, l, d, f, m, h, y, v, b, S, w, E, L, D, I) { const { cross: A } = n, M = ["INPUT", "SELECT", "TEXTAREA"], T = { passive: !1 }, O = x(), F = x(), P = g(50, 225).constrain(S.measure(20)), z = { mouse: 300, touch: 400 }, R = { mouse: 500, touch: 600 }, k = w ? 43 : 25; let B = !1, H = 0, V = 0, C = !1, N = !1, j = !1, G = !1; function q(n) { const e = l.readPoint(n), r = l.readPoint(n, A), o = c(e, H), i = c(r, V); if (!N && !G) { if (!n.cancelable) return U(n); if (N = o > i, !N) return U(n) } const u = l.pointerMove(n); o > E && (j = !0), h.useFriction(.3).useDuration(1), f.start(), a.add(t.apply(u)), n.preventDefault() } function U(n) { const e = y.byDistance(0, !1).index !== v.get(), r = l.pointerUp(n) * (w ? R : z)[G ? "mouse" : "touch"], u = function (n, t) { const e = v.add(-1 * i(n)), r = y.byDistance(n, !w).distance; return w || o(n) < P ? r : L && t ? .5 * r : y.byIndex(e.get(), 0).distance }(t.apply(r), e), s = function (n, t) { if (0 === n || 0 === t) return 0; if (o(n) <= o(t)) return 0; const e = c(o(n), o(t)); return o(e / n) }(r, u), a = k - 10 * s, d = D + s / 50; N = !1, C = !1, F.clear(), h.useDuration(a).useFriction(d), m.distance(u, !w), G = !1, b.emit("pointerUp") } function W(n) { j && (n.stopPropagation(), n.preventDefault()) } return { init: function (n) { if (!I) return; function t(t) { (e(I) || I(n, t)) && function (n) { const t = p(n, s); if (G = t, t && 0 !== n.button) return; if (function (n) { const t = n.nodeName || ""; return M.includes(t) }(n.target)) return; j = w && t && !n.buttons && B, B = c(a.get(), d.get()) >= 2, C = !0, l.pointerDown(n), h.useFriction(0).useDuration(0), a.set(d), function () { const n = G ? u : r; F.add(n, "touchmove", q, T).add(n, "touchend", U).add(n, "mousemove", q, T).add(n, "mouseup", U) }(), H = l.readPoint(n), V = l.readPoint(n, A), b.emit("pointerDown") }(t) } const o = r; O.add(o, "dragstart", (n => n.preventDefault()), T).add(o, "touchmove", (() => { }), T).add(o, "touchend", (() => { })).add(o, "touchstart", t).add(o, "mousedown", t).add(o, "touchcancel", U).add(o, "contextmenu", U).add(o, "click", W, !0) }, pointerDown: function () { return C }, destroy: function () { O.clear(), F.clear() } } } function v(n, t) { let e, r; function i(n) { return n.timeStamp } function c(e, r) { const o = "client" + ("x" === (r || n.scroll) ? "X" : "Y"); return (p(e, t) ? e : e.touches[0])[o] } return { pointerDown: function (n) { return e = n, r = n, c(n) }, pointerMove: function (n) { const t = c(n) - c(r), o = i(n) - i(e) > 170; return r = n, o && (e = n), t }, pointerUp: function (n) { if (!e || !r) return 0; const t = c(r) - c(e), u = i(n) - i(e), s = i(n) - i(r) > 170, a = t / u; return u && !s && o(a) > .1 ? a : 0 }, readPoint: c } } function b(n, t, r, i, c, u) { let s, a, l = [], d = !1; function f(n) { return c.measureSize(n.getBoundingClientRect()) } return { init: function (c) { if (!u) return; a = f(n), l = i.map(f), s = new ResizeObserver((s => { d || (e(u) || u(c, s)) && function (e) { for (const u of e) { const e = u.target === n, s = i.indexOf(u.target), d = e ? a : l[s]; if (o(f(e ? n : i[s]) - d) >= .2) { r.requestAnimationFrame((() => { c.reInit(), t.emit("resize") })); break } } }(s) })), [n].concat(i).forEach((n => s.observe(n))) }, destroy: function () { s && s.disconnect(), d = !0 } } } function S(n, t, e, r, i) { const c = i.measure(10), u = i.measure(50), s = g(.1, .99); let a = !1; return { constrain: function (i) { if (a || !n.reachedAny(e.get()) || !n.reachedAny(t.get())) return; const l = n.reachedMin(t.get()) ? "min" : "max", d = o(n[l] - t.get()), f = e.get() - t.get(), p = s.constrain(d / u); e.subtract(f * p), !i && o(f) < c && (e.set(n.constrain(e.get())), r.useDuration(25).useBaseFriction()) }, toggleActive: function (n) { a = !n } } } function w(n, t, e, r) { const o = t.min + .1, i = t.max + .1, { reachedMin: c, reachedMax: u } = g(o, i); return { loop: function (t) { if (!function (n) { return 1 === n ? u(e.get()) : -1 === n && c(e.get()) }(t)) return; const o = n * (-1 * t); r.forEach((n => n.add(o))) } } } function E(n, t, e, r, c) { const { reachedAny: u, removeOffset: a, constrain: l } = r; function d(n) { return n.concat().sort(((n, t) => o(n) - o(t)))[0] } function f(t, r) { const o = [t, t + e, t - e]; if (!n) return o[0]; if (!r) return d(o); const c = o.filter((n => i(n) === r)); return c.length ? d(c) : s(o) - e } return { byDistance: function (e, r) { const i = c.get() + e, { index: s, distance: d } = function (e) { const r = n ? a(e) : l(e), i = t.map((n => n - r)).map((n => f(n, 0))).map(((n, t) => ({ diff: n, index: t }))).sort(((n, t) => o(n.diff) - o(t.diff))), { index: c } = i[0]; return { index: c, distance: r } }(i), p = !n && u(i); return !r || p ? { index: s, distance: e } : { index: s, distance: e + f(t[s] - d, 0) } }, byIndex: function (n, e) { return { index: n, distance: f(t[n] - c.get(), e) } }, shortcut: f } } function L(t) { let e = t; function r(t) { return n(t) ? t : t.get() } return { get: function () { return e }, set: function (n) { e = r(n) }, add: function (n) { e += r(n) }, subtract: function (n) { e -= r(n) } } } function D(n, t, e) { const r = "x" === n.scroll ? function (n) { return `translate3d(${n}px,0px,0px)` } : function (n) { return `translate3d(0px,${n}px,0px)` }, o = e.style; let i = !1; return { clear: function () { i || (o.transform = "", e.getAttribute("style") || e.removeAttribute("style")) }, to: function (n) { i || (o.transform = r(t.apply(n))) }, toggleActive: function (n) { i = !n } } } function I(n, t, e, r, o, i, c, s, a, l) { const d = u(i), f = u(i).reverse(), p = function () { const n = s[0] - 1; return h(g(f, n), r, !1) }().concat(function () { const n = e - s[0] - 1; return h(g(d, n), -r, !0) }()); function m(n, t) { return n.reduce(((n, t) => n - i[t]), t) } function g(n, t) { return n.reduce(((n, e) => m(n, t) > 0 ? n.concat([e]) : n), []) } function h(i, u, s) { const d = function (n) { return c.map(((t, r) => ({ start: t - o[r] + .5 + n, end: t + e - .5 + n }))) }(u); return i.map((e => { const o = s ? 0 : -r, i = s ? r : 0, c = s ? "end" : "start", u = d[e][c]; return { index: e, slideLocation: L(-1), translate: D(n, t, l[e]), target: () => a.get() > u ? o : i } })) } return { canLoop: function () { return p.every((({ index: n }) => m(d.filter((t => t !== n)), e) <= .1)) }, clear: function () { p.forEach((n => n.translate.clear())) }, loop: function () { p.forEach((n => { const { target: t, translate: e, slideLocation: r } = n, o = t(); o !== r.get() && (e.to(o), r.set(o)) })) }, loopPoints: p } } function A(n, t, r) { let o, i = !1; return { init: function (c) { r && (o = new MutationObserver((n => { i || (e(r) || r(c, n)) && function (n) { for (const e of n) if ("childList" === e.type) { c.reInit(), t.emit("slidesChanged"); break } }(n) })), o.observe(n, { childList: !0 })) }, destroy: function () { o && o.disconnect(), i = !0 } } } function M(n, t, e, r) { const o = {}; let i, c = null, u = null, s = !1; return { init: function () { i = new IntersectionObserver((n => { s || (n.forEach((n => { const e = t.indexOf(n.target); o[e] = n })), c = null, u = null, e.emit("slidesInView")) }), { root: n.parentElement, threshold: r }), t.forEach((n => i.observe(n))) }, destroy: function () { i && i.disconnect(), s = !0 }, get: function (n = !0) { if (n && c) return c; if (!n && u) return u; const t = function (n) { return d(o).reduce(((t, e) => { const r = parseInt(e), { isIntersecting: i } = o[r]; return (n && i || !n && !i) && t.push(r), t }), []) }(n); return n && (c = t), n || (u = t), t } } } function T(t, e, r, i, c, l, d, f, p) { const { startEdge: m, endEdge: g } = t, h = n(i); return { groupSlides: function (n) { return h ? function (n, t) { return u(n).filter((n => n % t == 0)).map((e => n.slice(e, e + t))) }(n, i) : function (n) { return n.length ? u(n).reduce(((t, i) => { const u = s(t) || 0, h = 0 === u, x = i === a(n), y = l[m] - d[u][m], v = l[m] - d[i][g], b = !c && h ? e.apply(f) : 0; return o(v - (!c && x ? e.apply(p) : 0) - (y + b)) > r && t.push(i), x && t.push(n.length), t }), []).map(((t, e, r) => { const o = Math.max(r[e - 1] || 0); return n.slice(o, t) })) : [] }(n) } } } function O(t, e, r, c, d, f, p, O) { const { align: F, axis: P, direction: z, startIndex: R, loop: k, duration: B, dragFree: H, dragThreshold: V, inViewThreshold: C, slidesToScroll: N, skipSnaps: j, containScroll: G, watchResize: q, watchSlides: U, watchDrag: W } = f, $ = e.getBoundingClientRect(), Q = r.map((n => n.getBoundingClientRect())), X = function (n) { const t = "rtl" === n ? -1 : 1; return { apply: function (n) { return n * t } } }(z), Y = function (n, t) { const e = "y" === n ? "y" : "x"; return { scroll: e, cross: "y" === n ? "x" : "y", startEdge: "y" === e ? "top" : "rtl" === t ? "right" : "left", endEdge: "y" === e ? "bottom" : "rtl" === t ? "left" : "right", measureSize: function (n) { const { width: t, height: r } = n; return "x" === e ? t : r } } }(P, z), J = Y.measureSize($), K = function (n) { return { measure: function (t) { return n * (t / 100) } } }(J), Z = m(F, J), _ = !k && !!G, nn = k || !!G, { slideSizes: tn, slideSizesWithGaps: en, startGap: rn, endGap: on } = function (n, t, e, r, i, c) { const { measureSize: u, startEdge: l, endEdge: d } = n, f = e[0] && i, p = function () { if (!f) return 0; const n = e[0]; return o(t[l] - n[l]) }(), m = function () { if (!f) return 0; const n = c.getComputedStyle(s(r)); return parseFloat(n.getPropertyValue(`margin-${d}`)) }(), g = e.map(u), h = e.map(((n, t, e) => { const r = !t, o = t === a(e); return r ? g[t] + p : o ? g[t] + m : e[t + 1][l] - n[l] })).map(o); return { slideSizes: g, slideSizesWithGaps: h, startGap: p, endGap: m } }(Y, $, Q, r, nn, d), cn = T(Y, X, J, N, k, $, Q, rn, on), { snaps: un, snapsAligned: sn } = function (n, t, e, r, i) { const { startEdge: c, endEdge: u } = n, { groupSlides: a } = i, l = a(r).map((n => s(n)[u] - n[0][c])).map(o).map(t.measure), d = r.map((n => e[c] - n[c])).map((n => -o(n))), f = a(d).map((n => n[0])).map(((n, t) => n + l[t])); return { snaps: d, snapsAligned: f } }(Y, Z, $, Q, cn), an = -s(un) + s(en), { snapsContained: ln, scrollContainLimit: dn } = function (n, t, e, r) { const o = g(-t + n, 0), i = e.map(o.constrain).map((n => parseFloat(n.toFixed(3)))), c = function () { const n = i[0], t = s(i); return g(i.lastIndexOf(n), i.indexOf(t) + 1) }(); return { snapsContained: function () { if (t <= n) return [o.max]; if ("keepSnaps" === r) return i; const { min: e, max: u } = c; return i.slice(e, u) }(), scrollContainLimit: c } }(J, an, sn, G), fn = _ ? ln : sn, { limit: pn } = function (n, t, e) { const r = t[0]; return { limit: g(e ? r - n : s(t), r) } }(an, fn, k), mn = h(a(fn), R, k), gn = mn.clone(), hn = u(r), xn = { start: () => O.start(On), stop: () => O.stop(On), update: () => (({ dragHandler: n, scrollBody: t, scrollBounds: e, eventHandler: r, animation: o, options: { loop: i } }) => { const c = n.pointerDown(); i || e.constrain(c); const u = t.seek().settled(); u && !c && (o.stop(), r.emit("settle")), u || r.emit("scroll") })(On), render: n => (({ scrollBody: n, translate: t, location: e, offsetLocation: r, scrollLooper: o, slideLooper: i, options: { loop: c } }, u) => { const s = n.velocity(); r.set(e.get() - s + s * u), c && (o.loop(n.direction()), i.loop()), t.to(r.get()) })(On, n) }, yn = fn[mn.get()], vn = L(yn), bn = L(yn), Sn = L(yn), wn = function (n, t, e, r) { let c = !0, u = 0, s = 0, a = e, l = r, d = n.get(), f = 0; function p(n) { return a = n, g } function m(n) { return l = n, g } const g = { direction: function () { return s }, duration: function () { return a }, velocity: function () { return u }, seek: function () { const e = t.get() - n.get(); let r = 0; return a ? (u += e / a, u *= l, d += u, n.add(u), r = d - f) : (u = 0, n.set(t), r = e), s = i(r), f = d, c = o(e) < .001, g }, settled: function () { return c }, useBaseFriction: function () { return m(r) }, useBaseDuration: function () { return p(e) }, useFriction: m, useDuration: p }; return g }(vn, Sn, B, .68), En = E(k, fn, an, pn, Sn), Ln = function (n, t, e, r, o, i, c) { function u(r) { const u = r.distance, s = r.index !== t.get(); i.add(u), u && (o.duration() ? n.start() : (n.update(), n.render(1), n.update())), s && (e.set(t.get()), t.set(r.index), c.emit("select")) } return { distance: function (n, t) { u(r.byDistance(n, t)) }, index: function (n, e) { const o = t.clone().set(n); u(r.byIndex(o.get(), e)) } } }(xn, mn, gn, En, wn, Sn, p), Dn = function (n) { const { max: t, length: e } = n; return { get: function (n) { return e ? (n - t) / -e : 0 } } }(pn), In = x(), An = M(e, r, p, C), { slideRegistry: Mn } = function (n, t, e, r, o, i) { const { groupSlides: c } = o, { min: u, max: d } = r; return { slideRegistry: function () { const r = c(i); return !e || t <= n ? r : r.slice(u, d).map(((n, t, e) => { const r = !t, o = !r && t === a(e); return r ? l(s(e[0]) + 1) : o ? l(a(i) - s(e)[0] + 1, s(e)[0]) : n })) }() } }(J, an, _, dn, cn, hn), Tn = function (t, e, r, o, i, c) { let u = 0; function s(n) { "Tab" === n.code && (u = (new Date).getTime()) } function a(s) { c.add(s, "focus", (() => { if ((new Date).getTime() - u > 10) return; t.scrollLeft = 0; const c = e.indexOf(s), a = r.findIndex((n => n.includes(c))); n(a) && (i.useDuration(0), o.index(a, 0)) }), { passive: !0, capture: !0 }) } return { init: function () { c.add(document, "keydown", s, !1), e.forEach(a) } } }(t, r, Mn, Ln, wn, In), On = { ownerDocument: c, ownerWindow: d, eventHandler: p, containerRect: $, slideRects: Q, animation: xn, axis: Y, direction: X, dragHandler: y(Y, X, t, c, d, Sn, v(Y, d), vn, xn, Ln, wn, En, mn, p, K, H, V, j, .68, W), eventStore: In, percentOfView: K, index: mn, indexPrevious: gn, limit: pn, location: vn, offsetLocation: bn, options: f, resizeHandler: b(e, p, d, r, Y, q), scrollBody: wn, scrollBounds: S(pn, vn, Sn, wn, K), scrollLooper: w(an, pn, bn, [vn, bn, Sn]), scrollProgress: Dn, scrollSnapList: fn.map(Dn.get), scrollSnaps: fn, scrollTarget: En, scrollTo: Ln, slideLooper: I(Y, X, J, an, tn, en, un, fn, bn, r), slideFocus: Tn, slidesHandler: A(e, p, U), slidesInView: An, slideIndexes: hn, slideRegistry: Mn, slidesToScroll: cn, target: Sn, translate: D(Y, X, e) }; return On } const F = { align: "center", axis: "x", container: null, slides: null, containScroll: "trimSnaps", direction: "ltr", slidesToScroll: 1, inViewThreshold: 0, breakpoints: {}, dragFree: !1, dragThreshold: 10, loop: !1, skipSnaps: !1, duration: 25, startIndex: 0, active: !0, watchDrag: !0, watchResize: !0, watchSlides: !0 }; function P(n) { function t(n, t) { return f(n, t || {}) } const e = { mergeOptions: t, optionsAtMedia: function (e) { const r = e.breakpoints || {}, o = d(r).filter((t => n.matchMedia(t).matches)).map((n => r[n])).reduce(((n, e) => t(n, e)), {}); return t(e, o) }, optionsMediaQueries: function (t) { return t.map((n => d(n.breakpoints || {}))).reduce(((n, t) => n.concat(t)), []).map(n.matchMedia) } }; return e } function z(n, e, r) { const i = n.ownerDocument, c = i.defaultView, u = P(c), s = function (n) { let t = []; return { init: function (e, r) { return t = r.filter((({ options: t }) => !1 !== n.optionsAtMedia(t).active)), t.forEach((t => t.init(e, n))), r.reduce(((n, t) => Object.assign(n, { [t.name]: t })), {}) }, destroy: function () { t = t.filter((n => n.destroy())) } } }(u), a = x(), l = x(), d = function () { const n = {}; let t; function e(t) { return n[t] || [] } const r = { init: function (n) { t = n }, emit: function (n) { return e(n).forEach((e => e(t, n))), r }, off: function (t, o) { return n[t] = e(t).filter((n => n !== o)), r }, on: function (t, o) { return n[t] = e(t).concat([o]), r } }; return r }(), { animationRealms: f } = z, { mergeOptions: p, optionsAtMedia: m, optionsMediaQueries: g } = u, { on: h, off: y, emit: v } = d, b = k; let S, w, E, L, D = !1, I = p(F, z.globalOptions), A = p(I), M = []; function T(t, e) { const r = O(n, E, L, i, c, t, d, e); if (t.loop && !r.slideLooper.canLoop()) { return T(Object.assign({}, t, { loop: !1 }), e) } return r } function R(e, r) { if (D) return; const u = f.find((n => n.window === c)), d = u || function (n) { const t = 1e3 / 60; let e = [], r = null, i = 0, c = 0; function u(s) { r || (r = s); const a = s - r; for (r = s, i += a; i >= t;)e.forEach((({ animation: n }) => n.update())), i -= t; const l = o(i / t); e.forEach((({ animation: n }) => n.render(l))), c && n.requestAnimationFrame(u) } return { start: function (t) { e.includes(t) || e.push(t), c || (c = n.requestAnimationFrame(u)) }, stop: function (t) { e = e.filter((n => n !== t)), e.length || (n.cancelAnimationFrame(c), r = null, i = 0, c = 0) }, reset: function () { r = null, i = 0 }, window: n } }(c); u || f.push(d), I = p(I, e), A = m(I), M = r || M, function () { const { container: e, slides: r } = A, o = t(e) ? n.querySelector(e) : e; E = o || n.children[0]; const i = t(r) ? E.querySelectorAll(r) : r; L = [].slice.call(i || E.children) }(), S = T(A, d), g([I, ...M.map((({ options: n }) => n))]).forEach((n => a.add(n, "change", k))), A.active && (S.translate.to(S.location.get()), S.slidesInView.init(), S.slideFocus.init(), S.eventHandler.init(C), S.resizeHandler.init(C), S.slidesHandler.init(C), l.add(i, "visibilitychange", (() => { i.hidden && d.reset() })), S.options.loop && S.slideLooper.loop(), E.offsetParent && L.length && S.dragHandler.init(C), w = s.init(C, M)) } function k(n, t) { const e = V(); B(), R(p({ startIndex: e }, n), t), d.emit("reInit") } function B() { S.dragHandler.destroy(), S.animation.stop(), S.eventStore.clear(), S.translate.clear(), S.slideLooper.clear(), S.resizeHandler.destroy(), S.slidesHandler.destroy(), s.destroy(), a.clear(), l.clear() } function H(n, t, e) { A.active && !D && (S.scrollBody.useBaseFriction().useDuration(t ? 0 : A.duration), S.scrollTo.index(n, e || 0)) } function V() { return S.index.get() } const C = { canScrollNext: function () { return S.index.add(1).get() !== V() }, canScrollPrev: function () { return S.index.add(-1).get() !== V() }, containerNode: function () { return E }, internalEngine: function () { return S }, destroy: function () { D || (D = !0, a.clear(), B(), d.emit("destroy")) }, off: y, on: h, emit: v, plugins: function () { return w }, previousScrollSnap: function () { return S.indexPrevious.get() }, reInit: b, rootNode: function () { return n }, scrollNext: function (n) { H(S.index.add(1).get(), !0 === n, -1) }, scrollPrev: function (n) { H(S.index.add(-1).get(), !0 === n, 1) }, scrollProgress: function () { return S.scrollProgress.get(S.location.get()) }, scrollSnapList: function () { return S.scrollSnapList }, scrollTo: H, selectedScrollSnap: V, slideNodes: function () { return L }, slidesInView: function () { return S.slidesInView.get() }, slidesNotInView: function () { return S.slidesInView.get(!1) } }; return R(e, r), setTimeout((() => d.emit("init")), 0), C } return z.animationRealms = [], z.globalOptions = void 0, z }));